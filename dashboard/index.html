<script>
  let allEntries = [];
  let currentPage = 1;
  const entriesPerPage = 10;

  async function fetchClockEntries() {
    const res = await fetch('/api/clock-entries');
    allEntries = await res.json();
    applyFilters();
  }

  function applyFilters() {
    const start = document.getElementById('startDate').value;
    const end = document.getElementById('endDate').value;
    const worker = document.getElementById('workerFilter').value.toLowerCase();
    const project = document.getElementById('projectFilter').value.toLowerCase();

    let filtered = allEntries.filter(entry => {
      const dt = new Date(entry.datetime);
      const matchDate = (!start || new Date(start) <= dt) && (!end || dt <= new Date(end));
      const matchWorker = !worker || entry.worker_name?.toLowerCase().includes(worker);
      const matchProject = !project || entry.project_name?.toLowerCase().includes(project);
      return matchDate && matchWorker && matchProject;
    });

    displayEntries(filtered);
  }

  function clearFilters() {
    document.getElementById('startDate').value = '';
    document.getElementById('endDate').value = '';
    document.getElementById('workerFilter').value = '';
    document.getElementById('projectFilter').value = '';
    displayEntries(allEntries);
  }

  function displayEntries(entries) {
    const table = document.getElementById('entriesTable');
    table.innerHTML = '';

    const start = (currentPage - 1) * entriesPerPage;
    const paginated = entries.slice(start, start + entriesPerPage);

    for (let entry of paginated) {
      const dateTimeDisplay = entry.datetime && !isNaN(new Date(entry.datetime))
        ? new Date(entry.datetime).toLocaleString()
        : 'Invalid Date';

      const row = `<tr>
        <td>${entry.id}</td>
        <td>${entry.phone_number || ''}</td>
        <td>${entry.worker_name || ''}</td>
        <td>${entry.project_name || ''}</td>
        <td>${entry.action}</td>
        <td>${dateTimeDisplay}</td>
        <td>${entry.note || ''}</td>
      </tr>`;
      table.insertAdjacentHTML('beforeend', row);
    }

    setupPagination(entries.length);
  }

  function setupPagination(total) {
    const pagination = document.getElementById('pagination');
    pagination.innerHTML = '';
    const totalPages = Math.ceil(total / entriesPerPage);
    for (let i = 1; i <= totalPages; i++) {
      const btn = document.createElement('button');
      btn.textContent = i;
      if (i === currentPage) btn.disabled = true;
      btn.onclick = () => {
        currentPage = i;
        applyFilters();
      };
      pagination.appendChild(btn);
    }
  }

  function exportToCSV() {
    const rows = [["ID", "Phone Number", "Worker", "Project", "Action", "Date & Time", "Note"]];
    const start = (currentPage - 1) * entriesPerPage;
    const filtered = allEntries.slice(start, start + entriesPerPage);
    for (let e of filtered) {
      rows.push([
        e.id, e.phone_number, e.worker_name, e.project_name, e.action,
        new Date(e.datetime).toLocaleString(), e.note || ''
      ]);
    }
    const csv = rows.map(r => r.map(c => `"${c}"`).join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "clock_entries.csv";
    link.click();
  }

  function showAddModal() {
    document.getElementById('addModal').style.display = 'block';
    document.getElementById('overlay').style.display = 'block';
  }

  function hideAddModal() {
    document.getElementById('addModal').style.display = 'none';
    document.getElementById('overlay').style.display = 'none';
  }

  document.getElementById('addEntryForm').addEventListener('submit', async function (e) {
    e.preventDefault();
    const formData = new FormData(this);
    const data = Object.fromEntries(formData.entries());

    try {
      const res = await fetch('/api/clock-entries', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });

      if (!res.ok) throw new Error('Failed to add entry');

      hideAddModal();
      this.reset();
      fetchClockEntries();
      alert('Manual entry added!');
    } catch (err) {
      alert('Error: ' + err.message);
    }
  });

  fetchClockEntries();
</script>
